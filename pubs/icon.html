<!DOCTYPE HTML PUBLIC "-//SQ//DTD HTML 2.0 HoTMetaL + extensions//EN">
<HTML><HEAD>
<LINK HREF="mailto:drh@cs.princeton.edu" REV="made" TITLE="David R. Hanson">
<TITLE>A Brief Introduction to Icon</TITLE></HEAD>
<BODY>
<P><SMALL>Reprinted from <CITE>Preprints of the Second ACM SIGPLAN History of
Programming Languages Conference (HOPL-II), SIGPLAN Notices</CITE> <B>28</B>, 3
(1993), 359-360.</SMALL></P>
<H2>A Brief Introduction to Icon</H2>
<P>Icon is a very high-level imperative language with a rich repertoire of
string and structure processing facilities. It is available on a wide range of
computers and is in wide use.</P>
<P>In Icon, values, not variables, are typed. Built-in data types include
numerics, character sets, strings, sets, lists, associative tables, records, and
procedures. The aggregate types - sets, lists, tables, and records - can hold
values of any type. Tables can be indexed by values of any type. Numerics,
character sets, and strings are atomic values; operations on them produce new
values. Aggregates use pointer semantics; operations on them can change existing
values as well as produce new ones. Strings and aggregates can be of arbitrary
size, and their sizes can change during execution. Memory management is
automatic.</P>
<P>Icon has an expression-oriented syntax; even control structures are
expressions. Procedures consist of zero or more expressions separated by
newlines or semicolons. Icon programs consist of one or more procedure
definitions, and execution begins by calling the procedure named <TT>main</TT>.</P>
<P>Expressions can produce zero or more values. As in traditional languages,
many Icon expressions produce a single value, for example,
<TT>x+5</TT> produces the sum of <TT>x</TT> and
<TT>5</TT>. Other expressions can produce more than one value, for example,
<TT>x</TT> <TT>|</TT> <TT>5</TT> produces <TT>x</TT> then, if necessary,
produces <TT>5</TT>. Such expressions are called <I>generators</I>; there are
several built-in generators and procedures can be written to be generators.
Other examples of built-in generators include <TT>x</TT>
<TT>to</TT> <TT>y</TT>, which generates the integers from <TT>x</TT> to <TT>y</TT>,
and <TT>!x</TT>, which generates all the characters from string <TT>x</TT> or
the elements from aggregate <TT>x</TT>.</P>
<P>A `goal-directed' expression evaluation mechanism is Icon's most
distinguishing characteristic. Expression evaluation seeks `success' - at least
one value for an expression. An expression `fails' if it does not produce a
value. The evaluation mechanism tries all combinations of values from generators
in pursuit of a successful outcome. For example, <TT>y</TT> <TT>&lt;</TT>
<TT>(x</TT>
<TT>|</TT> <TT>5)</TT> first compares <TT>y</TT> to <TT>x</TT>. If <TT>y</TT>
is less than <TT>x</TT>, evaluation succeeds and produces the value <TT>x</TT>.
If <TT>y</TT> is not less than <TT>x</TT>, <TT>y</TT> is compared to <TT>5</TT>,
the next value generated by the subexpression <TT>x</TT> <TT>|</TT> <TT>5</TT>.
If <TT>y</TT> is less than <TT>5</TT>, evaluation succeeds and produces <TT>5</TT>.
Otherwise, evaluation fails, and no value is produced. Comparison operators
produce the value of their right operand if they succeed.</P>
<P>Failure drives control expressions and inhibits subsequent evaluation. For
example, <TT>max</TT> <TT>:=</TT> <TT>max</TT>
<TT>&lt;</TT> <TT>x</TT> sets <TT>max</TT> to <TT>x</TT> only when it is
less than <TT>x</TT>. Likewise,</P>
<P><TT>if y &lt; (x | 5) then write(&quot;y=&quot;, y)</TT></P>
<P>prints the value of <TT>y</TT> only if it is less than
<TT>x</TT> or <TT>5</TT>. The evaluation mechanism pervades Icon; for example,
procedures are called only if all of their arguments succeed, so the last
example could be written more succinctly as</P>
<P><TT>write(&quot;y=&quot;, (x | 5) &gt; y)</TT></P>
<P>The backtracking implied by the goal-directed evaluation mechanism is
limited to the expression in which it occurs. For example, in</P>
<P><TT>max := max &lt; x<BR> write(&quot;y=&quot;, (x | 5) &gt; y)</TT></P>
<P>failure in the second expression does not affect the outcome of the first.</P>
<P>The expression <TT>every</TT> <I>e</I>1 <TT>do</TT>
<I>e</I>2 `drives' <I>e</I>1 - it evaluates <I>e</I>2 for every successful
outcome of <I>e</I>1. So, if <TT>p</TT> is a list of 100 elements,</P>
<P><TT>every i := (1 to 10) | (91 to 100) do write(p[i])</TT></P>
<P>prints the first and last ten elements of <TT>p</TT>. The
<TT>do</TT> clause is optional, and the evaluation mechanism often helps
eliminate temporary variables like <TT>i</TT>, for example,</P>
<P><TT>every write(p[(1 to 10) | (91 to 100)])</TT></P>
<P>also prints the first and last ten elements of <TT>p</TT>, and</P>
<P><TT>every !p := 0</TT></P>
<P>sets each element of <TT>p</TT> to zero.</P>
<P>Icon has numerous built-in procedures and operators that help analyze
strings. Many of these take strings and positions as operands and return strings
or positions. Positions denote locations <I>between</I> characters. Strings can
be analyzed by manipulating positions explicitly, but Icon's <I>string scanning</I>
facility eliminates the need for most explicit positions. The expression <I>s</I>
<TT>?</TT> <I>e</I> establishes <I>s</I> as the subject to which string
processing operations in <I>e</I> apply. The expression
<I>e</I> typically includes string analysis operations, but may include <I>any</I>
operation. An example of a string analysis operation is <TT>find(</TT><I>s</I><TT>)</TT>,
which produces the positions in the subject at which <I>s</I> occurs as a
substring. For instance, if line is
</P>
<P><TT>&quot;a fish is a fish is a fish&quot;</TT></P>
<P>then</P>
<P><TT>every line ? write(find(&quot;fish&quot;))</TT></P>
<P>prints <TT>3</TT>, <TT>13</TT>, and <TT>23</TT>.</P>
<P>Another example is <TT>move(</TT><I>i</I><TT>)</TT>, which advances the
position by <I>i</I> characters. If the advancement is successful, <TT>move</TT>
returns the <I>i</I>-character substring between the initial and final
positions. For example,</P>
<P><TT>t := &quot;&quot;<BR> line ? while t := t || move(1) || &quot;.&quot;</TT></P>
<P>sets <TT>t</TT> to a string containing the characters of line followed by
periods; <TT>||</TT> denotes string concatenation.
<TT>while</TT> evaluates <TT>t</TT> <TT>:=</TT>
<TT>t</TT> <TT>||</TT> <TT>move(1)</TT> <TT>||</TT>
<TT>&quot;.&quot;</TT> repeatedly until it fails, which occurs when <TT>move(1)</TT>
is invoked at the end of the subject string.</P>
<P><TT>move</TT> is a <I>matching function</I> because it returns the
substring of the subject that is `matched' as a result of changing the position.
Another matching function is <TT>tab(</TT><I>i</I><TT>)</TT>, which moves to
position <I>i</I> in the subject and returns the substring between the old and
new positions.</P>
<P><TT>upto(</TT><I>s</I><TT>)</TT> returns the position of any of the
characters in <I>s</I>, and <TT>many(</TT><I>s</I><TT>)</TT> returns the
position following the longest possible substring containing only characters in
<I>s</I> starting at the current position. It is important to note that
functions like many return positions, but the specific values of those positions
are rarely important. Positions are used most often as arguments to matching
functions like <TT>tab</TT>. For example, the following function generates the
`words' in its argument.</P>
<PRE>procedure getword(str)
	str ? while tab(upto(&amp;letters)) do {
		word := tab(many(&amp;letters))
		suspend word
	}
end
</PRE>
<P><TT>&amp;letters</TT> contains all of the upper- and lowercase letters. The
expression <TT>tab(upto(&amp;letters))</TT> advances the position up to the
next letter, and <TT>tab(many(&amp;letters))</TT> matches the word and assigns
it to <TT>word</TT>. <TT>suspend</TT> is like <TT>return</TT>, but suspends
the invocation so that it can be <I>resumed</I> for alternate values, if
necessary. When the invocation is resumed, it continues where the <TT>suspend</TT>
left off, so subsequent resumptions return the remaining words. The <TT>while</TT>
terminates when <TT>tab(upto(&amp;letters))</TT> fails because there are no
more words in <TT>str</TT>.</P>
<P>An example of using <TT>getword</TT> is `common words,' a program that
lists the most commonly used words in its input and their frequencies of
occurrence. The line numbers are for explanatory purposes and are not part of
the program.</P>
<PRE>1	procedure main(args)
2		k := integer(args[1]) | 10
3		words := table(0)
4		while line := read() do every words[getword(line)] +:= 1
5		words := sort(words, 4)
6		every 1 to k do write(pull(words), &quot;\n&quot;, pull(words))
7	end 
</PRE>
<P>This program prints the <TT>k</TT> most commonly used words. Line 2 sets
<TT>k</TT> to the command-line argument, if there is one and it is a legal
integer, or to <TT>10</TT>. Line 3 assigns an associative table to <TT>words</TT>;
the argument to <TT>table</TT> specifies each entry's initial value. This table
accumulates the frequency counts. Line 4 reads in lines and uses <TT>getword</TT>
to generate the words in each line, which index <TT>words</TT>. The operator
<TT>+:=</TT> increments its left operand. <TT>sort(words,</TT>
<TT>4)</TT> in line 5 returns the contents of the table
<TT>words</TT> in a list sorted in increasing order by the frequency counts.
Indicies and their count values alternate in this list, which is assigned to
<TT>words</TT>. Line 6 prints the counts and words for the <TT>k</TT> most
frequently used words by <TT>pull</TT>ing them off the end of the list, which
also shortens the list. <TT>pull</TT> fails when the list is empty, in case
there are not <TT>k</TT> words.</P>
<P>This example typifies Icon programs. Most are much shorter than equivalent
programs in traditional languages, for example, compare this 13-line Icon
program with an equivalent program written in the C programming language (<I>Comm.
ACM</I> 30, 594-599, 1987; a
<A HREF="http://www.cs.princeton.edu/~drh/pubs/common.ps">PostScript</A>
version is available.</P>
<HR>
<ADDRESS>-<A HREF="http://www.cs.princeton.edu/~drh/">David R. Hanson</A>, <A
HREF="http://www.cs.princeton.edu/">Department of Computer Science</A>, <A
HREF="http://www.princeton.edu/">Princeton University</A><BR><A
HREF="mailto:drh@cs.princeton.edu">drh@cs.princeton.edu</A> / Wed Jul 26 09:02:01 EDT 1995</ADDRESS></BODY></HTML>
